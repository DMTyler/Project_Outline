using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEngine;

namespace DGraphics.PostProcessing.Outline
{
    public class OutlineController
    {
        # region Parameters
        private const string _outlinePass = @"
        // Auto-generated by OutlineSetter.cs
        // <<DG_AUTO_GEN_OUTLINE_MARKER>>
        Pass
        {
            Name ""OutlineInfo""
            Tags 
            { 
                ""LightMode"" = ""OutlineInfo""
                ""RenderType"" = ""Opaque"" 
            }
            Offset -0.01, -0.01

            ZWrite Off
            ZTest LEqual
            
            HLSLPROGRAM

            #include ""Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl""
            #include ""Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl""
            #pragma vertex vert
            #pragma fragment frag

            int _DG_AUTOGEN_OUTLINE_INDEX_;

            struct VertIn
            {
                float4 positionOS : POSITION;       // Position in Object Space
                float3 normal     : NORMAL;         // Normal in World Space
            };

            struct VertOut
            {
                float4 positionCS : SV_POSITION;    // Position in Clip Space
                float3 normal     : NORMAL;
                float3 positionVS    : TEXCOORD1;   // Position in View Space
            };

            VertOut vert(VertIn input)
            {
                VertOut output;
                float4 posWS = mul(unity_ObjectToWorld, input.positionOS);    // World Space
                float4 posVS = mul(UNITY_MATRIX_V, posWS);                    // View Space
                output.positionVS = posVS.xyz;                                 

                output.positionCS = mul(UNITY_MATRIX_P, posVS);               // Clip Space
                output.normal = TransformObjectToWorldNormal(input.normal);
                return output;
            }

            float4 frag(VertOut input) : SV_Target
            {
                float linearZ = -input.positionVS.z;
                float3 normal = normalize(input.normal);
                int index = _DG_AUTOGEN_OUTLINE_INDEX_;
                return float4(normal.rg, linearZ, index);  // RGB: normal, A: linearZ
            }
            ENDHLSL
        }    
        // End of auto-generated code
        ";

        private const string _depthOnlyPass = @"
        // Auto-generated by OutlineSetter.cs
        // <<DG_AUTO_GEN_DEPTH_ONLY_MARKER>>
        Pass
        {
            Name ""DepthOnly""
            Tags
            {
                ""LightMode"" = ""DepthOnly""
            }

            ZWrite On
            ColorMask R

            HLSLPROGRAM
            #pragma target 2.0
            #pragma vertex DepthOnlyVertex
            #pragma fragment DepthOnlyFragment

            #pragma shader_feature_local_fragment _ALPHATEST_ON

            #pragma multi_compile_fragment _ LOD_FADE_CROSSFADE

            #pragma multi_compile_instancing
            #include_with_pragmas ""Packages/com.unity.render-pipelines.universal/ShaderLibrary/DOTS.hlsl""

            #include ""Packages/com.unity.render-pipelines.universal/Shaders/UnlitInput.hlsl""
            #include ""Packages/com.unity.render-pipelines.universal/Shaders/DepthOnlyPass.hlsl""
            ENDHLSL
        ";


        private const string _configFolderPath = "Assets/Settings/DGraphics";
        private const string _configFileName = "OutlineConfig.json";
        private static string _configFullPath = Path.Combine(_configFolderPath, _configFileName);
        #endregion
        
        #region Register
        public static bool RegisterInfo(OutlineSetter setter)
        {
            
            if (OutlineSettings.Instance == null) return false;
            return OutlineSettings.Instance.AddOutlineSetter(setter);
        }
        
        public static void UnregisterInfo(OutlineSetter setter)
        {
            if (OutlineSettings.Instance == null) return;
            OutlineSettings.Instance.RemoveOutlineSetter(setter);
        }

        public static bool TryGetShaderBuffers(out ComputeBuffer outlineColors, out ComputeBuffer outlineParams) 
        {
            outlineColors = null;
            outlineParams = null;
            if (OutlineSettings.Instance == null) return false;
            var setters = OutlineSettings.Instance.OutlineSetters;
            if (setters.Count == 0) return false;
            
            OutlineSettings.Instance.UpdateIndexes();
            var colors = new Vector4[setters.Count];
            var paras = new Vector4[setters.Count];
            for (var i = 0; i < setters.Count; i++)
            {
                if (setters[i] == null || setters[i].OutlineInfo == null)
                {
                    Debug.LogWarning($"Setter {i} is null or has no outline info.");
                    continue;
                }
                
                colors[i] = setters[i].OutlineInfo.OutlineColor;
                paras[i] = new Vector4(
                    setters[i].OutlineInfo.OutlineWidth,
                    setters[i].OutlineInfo.Threshold,
                    setters[i].OutlineInfo.NormalStrength,
                    setters[i].OutlineInfo.DepthStrength
                );
            }
            outlineColors = new ComputeBuffer(colors.Length, sizeof(float) * 4, ComputeBufferType.Default);
            outlineColors.SetData(colors);
            outlineParams = new ComputeBuffer(paras.Length, sizeof(float) * 4, ComputeBufferType.Default);
            outlineParams.SetData(paras);
            return true;
        }
        #endregion
        
#if UNITY_EDITOR
        
        #region Setup Shader
        public static void SetupGameObjectShader(GameObject go)
        {
            var renderer = go.GetComponent<Renderer>();
            if (renderer == null) return;
            
            var material = renderer.sharedMaterial;
            if (material == null) return;
            
            var shader = material.shader;
            
            if (IsShaderGraph(shader))
            {
                Debug.LogError("Shader Graph is not supported. Please generate shader code first.\n " +
                               "To do this, click on the Show Generated Code button and copy the code to a shader file.");
                return;
            }
            
            var path = AssetDatabase.GetAssetPath(shader);
            var content = new List<string>(File.ReadAllLines(path));
            
            if (ContainOutlineMarker(content))
            {
                Debug.LogWarning($"GameObject {go.name} already has been setup.");
                return;
            }

            var insertLine = FindOutlinePassInsertLine(content);
            if (insertLine != -1)
            {
                content.Insert(insertLine, _outlinePass);
            }
            else
            {
                Debug.LogWarning($"No suitable insertion point found for Material {material.name}.");
                return;
            }
            
            insertLine = FindDepthOnlyPassInsertLine(content);
            if (insertLine != -1)
            {
                content.Insert(insertLine, _depthOnlyPass);
            }

            ReplaceShaderPath(content);

            var folderPath = "Assets/Shaders/auto-gen";
            var gid = GlobalObjectId.GetGlobalObjectIdSlow(go);
            var gidStr = gid.ToString();
            gidStr = gidStr.Replace(":", "_");
            var fileName = $"AutoGenOutline-{gidStr}.shader";
            var fullPath = Path.Combine(folderPath, fileName);
            if (!Directory.Exists(folderPath))
            {
                Directory.CreateDirectory(folderPath);
                Debug.Log($"Created folder: {folderPath}");
            }

            if (File.Exists(fullPath))
            {
                Debug.LogWarning($"File already exists: {fullPath}. This operation will overwrite the existing file.");
            }

            File.WriteAllLines(fullPath, content.ToArray());
            AssetDatabase.ImportAsset(fullPath);
            SaveRecord(go, shader.name);
            
            var newShader = AssetDatabase.LoadAssetAtPath<Shader>(fullPath);
            var newMaterial = new Material(material);
            newMaterial.shader = newShader;
            renderer.sharedMaterial = newMaterial;
        }
        
        public static void SetupMaterialShader(Material material)
        {
            var shader = material.shader;

            if (IsShaderGraph(shader))
            {
                Debug.LogError("Shader Graph is not supported. Please generate shader code first.\n " +
                               "To do this, click on the Show Generated Code button and copy the code to a shader file.");
                return;
            }
            
            var path = AssetDatabase.GetAssetPath(shader);
            var content = new List<string>(File.ReadAllLines(path));
            
            if (ContainOutlineMarker(content))
            {
                Debug.LogWarning($"Material {material.name} already has been setup.");
                return;
            }

            var insertLine = FindOutlinePassInsertLine(content);
            if (insertLine != -1)
            {
                content.Insert(insertLine, _outlinePass);
            }
            else
            {
                Debug.LogWarning($"No suitable insertion point found for Material {material.name}.");
                return;
            }
            
            insertLine = FindDepthOnlyPassInsertLine(content);
            if (insertLine != -1)
            {
                content.Insert(insertLine, _depthOnlyPass);
            }

            ReplaceShaderPath(content);

            var folderPath = "Assets/Shaders/auto-gen";
            var gid = GlobalObjectId.GetGlobalObjectIdSlow(material);
            var gidStr = gid.ToString();
            gidStr = gidStr.Replace(":", "_");
            var fileName = $"AutoGenOutline-{gidStr}.shader";
            var fullPath = Path.Combine(folderPath, fileName);
            if (!Directory.Exists(folderPath))
            {
                Directory.CreateDirectory(folderPath);
                Debug.Log($"Created folder: {folderPath}");
            }

            if (File.Exists(fullPath))
            {
                Debug.LogWarning($"File already exists: {fullPath}. This operation will overwrite the existing file.");
            }

            File.WriteAllLines(fullPath, content.ToArray());
            Debug.Log($"Wrote shader file at: {fullPath}");
            AssetDatabase.ImportAsset(fullPath);
            SaveRecord(material, shader.name);
            
            var newShader = AssetDatabase.LoadAssetAtPath<Shader>(fullPath);
            material.shader = newShader;
        }
        
        public static bool IsShaderGraph(Shader shader)
        {
            if (shader == null) return false;

            string path = AssetDatabase.GetAssetPath(shader);
            if (string.IsNullOrEmpty(path)) return false;

            var importer = AssetImporter.GetAtPath(path);
            if (importer == null) return false;

            var shaderGraphImporterType = Type.GetType("UnityEditor.ShaderGraph.ShaderGraphImporter, Unity.ShaderGraph.Editor", false);

            if (shaderGraphImporterType == null) return false;
            return shaderGraphImporterType.IsInstanceOfType(importer);
        }

        private static bool ContainOutlineMarker(List<string> content)
        {
            foreach (var line in content)
            {
                if (line.Contains("<<DG_AUTO_GEN_OUTLINE_MARKER>>")) return true;
            }
            return false;
        }

        private static int FindOutlinePassInsertLine(IReadOnlyList<string> content)
        {
            var braceDepth = 0;
            var insertLine = -1;
            var subShaderMet = false;
            for (var i = 0; i < content.Count; i++)
            {
                var line = content[i];
                
                if (line.Contains("SubShader"))
                {
                    subShaderMet = true;
                }
                
                if (!subShaderMet) continue;
                for (var j = 0; j < line.Length; j++)
                {
                    var c = line[j];
                    if (c == '{') braceDepth++;
                    if (c == '}')
                    {
                        braceDepth--;
                        if (braceDepth == 0)
                        {
                            insertLine = i;
                        }
                    }
                }

                if (insertLine >= 0) break;
            }

            return insertLine;
        }
        
        private static int FindDepthOnlyPassInsertLine(IReadOnlyList<string> content)
        {
            const string depthOnlyLightModeRegex = @"^\s*""LightMode""\s*=\s*""DepthOnly""";
            var braceDepth = 0;
            var insertLine = -1;
            var subShaderMet = false;
            for (var i = 0; i < content.Count; i++)
            {
                var line = content[i];
                
                if (Regex.Match(line, depthOnlyLightModeRegex).Success)
                {
                    return -1;
                }

                if (line.Contains("<<DG_AUTO_GEN_DEPTH_ONLY_MARKER>>"))
                {
                    return -1;
                }
                
                if (line.Contains("SubShader")) subShaderMet = true;
                if (!subShaderMet) continue;
                for (var j = 0; j < line.Length; j++)
                {
                    var c = line[j];
                    if (c == '{') braceDepth++;
                    if (c == '}')
                    {
                        braceDepth--;
                        if (braceDepth == 0)
                        {
                            insertLine = i;
                        }
                    }
                }

                if (insertLine >= 0) break;
            }

            return insertLine;
        }

        private static void ReplaceShaderPath(List<string> content)
        {
            var shaderText = @"^(\s*)Shader\s*""([^""]+)""";
            var replacement = @"$1Shader ""Hidden/DGraphics/AutoGen/$2""";
            for (var i = 0; i < content.Count; i++)
            {
                var line = content[i];
                var match = Regex.Match(line, shaderText);
                if (match.Success)
                {
                    content[i] = Regex.Replace(line, shaderText, replacement);
                    return;
                }
            }

            Debug.LogWarning("Failed to replace shader path.");
        }
        #endregion
        
        #region Revert Shader
        [Serializable]
        private struct ShaderOverrideDataKeyValue
        {
            public string Key;
            public string Value;
        }
        
        [Serializable]
        private class ShaderOverrideData : ISerializationCallbackReceiver
        {
            public Dictionary<string, string> gameObjectToShaderMap = new Dictionary<string, string>();
            
            [SerializeField] 
            private List<ShaderOverrideDataKeyValue> _serializedMap = new();
            
            public void OnBeforeSerialize()
            {
                _serializedMap.Clear();
                foreach (var kv in gameObjectToShaderMap)
                {
                    _serializedMap.Add(new ShaderOverrideDataKeyValue()
                    {
                        Key = kv.Key,
                        Value = kv.Value
                    });
                }
            }

            public void OnAfterDeserialize()
            {
                gameObjectToShaderMap.Clear();
                foreach (var kv in _serializedMap)
                {
                    gameObjectToShaderMap[kv.Key] = kv.Value;
                }
            }
        }
        
        public static void RevertGameObjectShader(GameObject go)
        {
            var renderer = go.GetComponent<Renderer>();
            if (renderer == null) return;
            
            var gid = GlobalObjectId.GetGlobalObjectIdSlow(go);
            var gidStr = gid.ToString();
            var data = LoadData();
            if (data.gameObjectToShaderMap.TryGetValue(gidStr, out var shader))
            {
                renderer.sharedMaterial.shader = Shader.Find(shader);
            }
            else
            {
                Debug.LogWarning($"No shader override record found for GameObject {go.name}.");
            }
        }
        
        public static void RevertMaterialShader(Material material)
        {
            
            var gid = GlobalObjectId.GetGlobalObjectIdSlow(material);
            var gidStr = gid.ToString();
            var data = LoadData();
            if (data.gameObjectToShaderMap.TryGetValue(gidStr, out var shader))
            {
                material.shader = Shader.Find(shader);
            }
            else
            {
                Debug.LogWarning($"No shader override record found for Material {material.name}.");
            }
        }

        private static void SaveRecord(UnityEngine.Object go, string shader)
        {
            var gid = GlobalObjectId.GetGlobalObjectIdSlow(go);
            var gidStr = gid.ToString();
            
            var data = LoadData();
            data.gameObjectToShaderMap[gidStr] = shader;
            SaveData(data);
        }
        
        private static ShaderOverrideData LoadData()
        {
            ShaderOverrideData cachedData;
            if (!Directory.Exists(_configFolderPath))
            {
                Directory.CreateDirectory(_configFolderPath);
                Debug.Log($"No config folder found at: {_configFolderPath}. Path created.");
            }
            
            if (!File.Exists(_configFullPath))
            {
                cachedData = new ShaderOverrideData();
                Debug.Log($"No config file found at: {_configFullPath}. File created.");
            }
            else
            {
                var jsonContent = File.ReadAllText(_configFullPath);
                cachedData = JsonUtility.FromJson<ShaderOverrideData>(jsonContent);
                if (cachedData == null)
                {
                    // If the JSON is invalid, create a new one
                    cachedData = new ShaderOverrideData();
                }
            }
            return cachedData;
        }

        private static void SaveData(ShaderOverrideData data)
        {
            var jsonContent = JsonUtility.ToJson(data, true);
            File.WriteAllText(_configFullPath, jsonContent);
            AssetDatabase.Refresh();
        }
        #endregion
        
#endif
    }
}